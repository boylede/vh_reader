//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: mdb.bt
//   Authors: 
//   Version: 0.0.1
//   Purpose: read Valheim map files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------


LittleEndian();

typedef struct {
    char len;
    if (len > 0) {
        char value[len];
    }
} PString <read=ReadPString, optimize=false>;

string ReadPString( PString &str ) {
    if( exists( str.value ) )
        return str.value;
    else
        return "";
}

typedef struct {
    float x;
    float y;
    float z;
} Pos;


typedef struct {
    float w;
    float x;
    float y;
    float z;
} Quat;

typedef struct {
    uquad stale_pointer; // wild guess
    int entity_id;    // wild guess
    int len;
    char content[len];
} Entity_COPY <optimize=false>;

typedef struct {
    int unknown_b;
    float hit_points;
} Hitpoints;

typedef struct {
    int tt;
    float xx;
    float yy;
    float zz;
} GroupThree;

typedef struct {
    int a;
    int b;
} Eightbytes;

typedef struct {
    int a;
    int b;
    int c;
} Twelvebytes;

typedef struct {
    int pre;
    uchar len;
    if (len > 127) {
        char sometimes;
    }
    char payload[len];
} StringPayload <optimize=false>;

// maybe these are actually like packets of data that
// need to be collected together according to group_id?
typedef struct {
    uquad group_id; // wild guess
    int entity_id;    // wild guess
    int len;
    local uquad end = FTell() + len;
    int two;  // might be linked to the "pairs" at the end?
    int four; // ^^
    char has_more_info; // this whole thing is built up of gueses right now.
    uquad other_id;
    int a;
    int b;
    int c;
    int d;
    char unknown[2];
    int e; // might be linked to the "pairs" at the end?
    int f; // ^^
    Pos position;
    Quat rotation; // well its four floats at any rate, maybe a quaternion
    char has_health; // guess observed 0 = no hp values, 1 = hp values, 2 = is healed? after repairing items i found damaged.
    if (has_health > 0) {
        Hitpoints hits[has_health];
        //char content[len - 80]; // - 71 + 8 = -80
    } else {
        //char content[len - 72]; // - 71 + 8 = -80
    }
    char has_third_group;
    if (has_third_group > 0) {
        GroupThree threes[has_third_group];
    } 
    char idk_1;
    if (idk_1 != 0) {
        Printf("Entity # %d had more info (1) to tell at %Lx.\n", entity_id, FTell());
        //local uquad remaining = end - FTell() - 3;
        //Printf("Entity # %d had more info (1) to tell at %Lx, choosing %Ld bytes (has %d health boxes)\n", entity_id, FTell(), remaining, has_health);
        char idk_1_payload[20];
        //sixteen bytes?? idk_1_payload[idk_1];
    }
    char idk_2;
    if (idk_2 != 0) {
        //Printf("Entity # %d had more info (2) to tell at %Lx.\n", entity_id, FTell());
        Eightbytes idk_2_item[idk_2];
        //int idk_2_a;
        //int idk_2_b;
    }
    char idk_3;
    if (idk_3 != 0) {
        //Printf("Entity # %d had more info (3) to tell at %Lx.\n", entity_id, FTell());
        Twelvebytes idk_3_payload[idk_3];
    }
    // base64 encoded payload
    char has_payload;
    if (has_payload != 0) {
        Printf("Entity # %d had more info (4) to tell at %Lx.\n", entity_id, FTell());
        //int pre_payload;
        //uchar payload_length;
        //if (payload_length > 127) {
        //    char sometimes;
        //    if (sometimes == 'Z') {
        //        Printf("Entity # %d @ %Lx lacked expected padding that sometimes is there and sometimes not??\n", entity_id, FTell());
        //    }
        //}
        //char payload[payload_length];
        StringPayload payload[has_payload];
    }
    //char content[len - 80]; // - 71 + 8 = -80
// sometimes entities are chests
// if so they have a base64-encoded payload
// seems to be identifiable by the bytes c6 10 0a c8
// preceeding a length byte, and that many bytes of b64 data.
// the data is at the very end of the entity content
    if (FTell() != end) {
        Printf("Entity # %d ended at %Lx instead of %Lx\n", entity_id, FTell(), end);
        return 0;
    }
} Entity <optimize=false>;

typedef struct Blocky(int len) {
    local int length = len;
    char block[len];
} Block <read=readBlock, optimize=false>;

string readBlock(Block &b) {
    string s;
    SPrintf( s, "%x", b.length );
    return s;
}

typedef struct {
    uquad group_id; // seems to reference back to entities?
    int c;
    uquad shared_id; // is shared between some number of "Twenty"
} Twenty;


// current hypothosis: these are deleted entity ids.
typedef struct {
    int count;
    Twenty items[count];
} Twenties <optimize = false>;

// usually one is positive and the other negative,
// but it switches in different files which is which
typedef struct {
    int a;
    int b;
} Pair;

typedef struct {
    PString name;
    float x;
    float y;
    float z;
    char seen;
} Structure <read=ReadStructure, optimize=false>;

string ReadStructure( Structure &it ) {
    if( exists( it.name.value ) )
        return it.name.value;
    else
        return "";
}

void analyze_records() {
    local int smallest_record = 100000;
    local int largest_record = 0;
    local int64 largest_record_address;
    local int record_count = 0;
    local int marker_value = ReadInt();
    local int64 cursor = FTell() + 4;
    local int64 end = FileSize() - 4;
    local int distance = 0;
    local int test = 0;
    while (cursor < end) {
        test = ReadInt(cursor);
        
        if (test == marker_value) {
            Block record(distance+4);
            Printf("Record Size: %d == 0x%x\n", distance, distance);
            if (distance < smallest_record) {
                smallest_record = distance;
            }
            if (distance > largest_record) {
                largest_record = distance;
                largest_record_address = cursor - distance;
            }
            distance = 0;
            cursor += 4;
            record_count += 1;
        }
        cursor += 1;
        distance += 1;
    }
    Block record(distance+4);
    Printf("found %d records. smallest was %d bytes, largest was %d at 0x%x", record_count, smallest_record, largest_record, largest_record_address);
}

typedef struct {
    PString name <name="name">;
    int quantity;
    float durability;
    int column;
    int row;
    char equipped;
    int quality;
    int unknown_a <bgcolor=cLtYellow>;
    uquad creator_id <name="creator id">;
    PString creator_name <name="creator name">;
} Item;

// found some base64 encoded info in some files
// appears to be contents of chests
// after decoding looks like: 
typedef struct {
    int version; // 103, also appears adjacent to character inventory, either a version tag or a type tag (ie inventory could be component type 103)
    int quantity; // number of items in the chest.
    Item items[quantity] <optimize=false>;
} Chest;

typedef struct {
    int something;
    int count;
    Entity entries[count] <name = "entity">;
} Entities;

typedef struct {
    int ninety_nine; // one of these maya be the version/Type
    int twenty_two;
    int zero;
    char one; // probably a bool?
    int count;
    Structure entries[count] <name = "structure">;
} Structures;

typedef struct {
    int version;
    int unknown;
    float time;
    char whatever[8];
} Header;

typedef struct {
    int count;
    Pair pairs[count];
} Pairs;

typedef struct {
    float float_b;
    char seventeen_zeros[17];
} Footer;

typedef struct {
    Header header <name = "header">;
    Entities entities <name = "entities">;
    Twenties twenties <name = "twenties">;
    Pairs pairs <name = "pairs">;
    Structures structures <name = "structures">;
    Footer footer <name = "footer">;
} MapFile;

MapFile map;
